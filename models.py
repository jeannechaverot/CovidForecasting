"""@ authors: Andrei Militaru, Jeanne Chaverot@ date: 5th of April 2020"""import numpy as npclass CompartmentManager(object):    """    Class that lets multiple cells interact with one another and evolve. In principle,    no specific model has been assumed, although for the moment only the SIR has been    implemented.    """        def __init__(self, parameters_list, link=1e-3, model='SIR', stochastic=False):        """        ---------------------        Parameters:            parameters_list: list                 dictionaries containing the keywords used in the                 initialization of the models of every cell. The number of cells is inferred                from the number of elements of paramaters_list            link: float, optional                strenght of interaction between the cell. At the present time, every cell                is assumed to interact in the same way with all the others.                Defaults to 1e-3.            model: str, optional                Choose between different available methods. At present:                    - 'SIR' (susceptible-infected-recovered)                    - 'SEIR' (susceptible-exposed-infected-recovered)                Defaults to 'SIR'.            stochastic: bool, optional                If True, the evolution of the model is chosen to be stochastic.                Defaults to False.        ----------------------        """                        self.link = link    # so far all the same, later we should make them non-uniform        self.compartments = []        self.elapsed_days = 1        for parameters in parameters_list:            if model == 'SIR':                if not stochastic:                    self.compartments.append(DeterministicSRI(**parameters))                else:                    self.compartments.append(StochasticSRI(**parameters))            elif model == 'SEIR':                if not stochastic:                    self.compartments.append(DeterministicSEIR(**parameters))                else:                    self.compartments.append(StochasticSEIR(**parameters))            else:                raise Exception('Model not valid. Only options are \'SIR\' or \'SEIR\'.')        def reset_state_all(self):        """        Resets the state of all the cells, meaning that the integration step is over.        """        for cell in self.compartments:            cell.updated = False        return self        def integrate(self):        """        Method that updates every cell. The cross terms in the evolution step are always        given by the population before the integration step. In order to avoid some for        some cells the evolution makes use of the already-updated populations from other        cells, an internal state of every cell is introduced.        """        for updating_cell in self.compartments:            for other_cell in self.compartments:                updating_cell.increment_partial(other_cell, self.link)  # due to other cells            updating_cell.integrate(add_partial=True)   # evolve cell            updating_cell.change_state()                # set cell as already updated        self.reset_state_all()                          # completion of integration step        self.elapsed_days += 1        return self            def evolve(self, days, tqdm=False):        """        Let the systems evolve for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is shown during the evolution.                Defaults to False.        -------------------        """                    if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self    def population(self, index):        """        Property that returns a list with the vector of population return elements in time.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        -----------------        """        output = []        for cell in self.compartments:            output.append(cell.population_by_index(index))        return output    '''    =========================================================    Part specific to SIR models, need to make it more general.    =========================================================    '''    @property    def S(self):        """        Property that returns a list with the vector of susceptible elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.S)        return output                @property    def I(self):        """        Property that returns a list with the vector of infected elements in time        of every cell.        """         output = []        for cell in self.compartments:            output.append(cell.I)        return output                @property    def R(self):        """        Property that returns a list with the vector of recovered elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.R)        return output        @property    def time(self):        """        Property that returns an array corresponding to the elapsed time.        """        return np.arange(self.elapsed_days)            class ModelBase(object):    """    Class that contains some of the methods used by all models to follow.    """    initial_population = None    population = None    N = None    initialized = False    population_history = None    updated = False    S_index = 0    partial_deltaI = 0    def __init__(self, initial_population=None, S_index=None):        """        ---------------        Parameters:            initial_population: list of int, optional                List of populations for the model of choice (provided by child classes).                If None, the reset method must be overloaded by the child class.        """        if initial_population is None:            pass        else:            self.population = len(initial_population)            self.initial_population = initial_population            self.N = sum(initial_population)            self.initialized = True            self.reset()            self.initialized = True            if S_index is not None:                self.S_index = S_index    def increment_partial(self, other, link):        """        Method used by instances of CompartmentManager to update the interactions with        other cells.        ------------------        Parameters:            other: instance of SRI (or its child classes)                cell that interacts with the current instance.            link: float                Interaction strength with the 'other' cell.        ------------------        """        self.partial_deltaI += link*other.currentI        return self    def reset(self):        """        If self.initialized (meaning that child class relies on this method), resets all parameters.        """        if self.initialized:            self.population_history = [[initial] for initial in self.initial_population]        else:            pass        return self    def integrate(self):        """        This method is overloaded by the child classes.        """        pass    def evolve(self, days, tqdm=False):        """        Compute evolution for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is used during the evolution.                Defaults to False.        -------------------        """        if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self    def change_state(self):        """        Method used by instance of CompartmentManager to make sure that only the        present populations are used when updating the interactions with other cells.        """        self.updated = not self.updated        return self    def population_by_index(self, index):        """        Method overloaded by child classes.        """        pass    @property    def S(self):        """        If not overloaded by child classes, returns the history of the self.S_index population.        """        if self.initialized:            return np.array(self.population_history[self.S_index])        else:            return None    @property    def time_elapsed(self):        """        Returns the number of days elapsed, given by the lengh of its populations.        It is assumed here that all models that follow have a population of susceptible individuals.        """        return len(self.S)    @property    def time(self):        """        Returns a numpy.ndarray corresponding to the elapsed time.        """        return np.arange(self.time_elapsed)    def integrate_deterministic(self, child, increments):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            child: instance of a deterministic model. The model must have a method current_by_index implemented.                See for example DeterministicSEIR.            increments: tuple of int                increments corresponding to each population type        ------------------        """        for population_type, increment in enumerate(increments):            current_value = child.current_by_index(population_type)            self.population_history[population_type].append(current_value + increment)        return self    def stochastic_jumps(self, jumps):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            jumps: tuple of int                jumps calculated in a deterministic evolution. The function converts them to poissonian variables                and returns a realization for each.        ------------------        """        return tuple([np.random.poisson(lam=np.abs(jump)) for jump in jumps])class SRI(ModelBase):    """    Parent class for SIR model. It provides methods and properties useful both for a    deterministic and for a stochastic implementation.    """        def __init__(self, beta=0.2, gamma=0.5, S0=999, I0=1, R0=0):        """        ----------------------        Paramenters:            beta: float, optional                Flow from susceptible to infected. Defaults to 0.2.            gamma: float, optional                Flow from infected to recovered. Defaults to 0.5.            S0: int, optional                Initial number of susceptible individuals.                Defaults to 999.            I0: int, optional                Initial number of infected individuals. Defaults to 1.            R0: int, optional                Initial number of recovered individuals. Defaults to 0.        -----------------------        """        super().__init__()        self.S0 = S0        self.I0 = I0        self.R0 = R0        self.beta = beta        self.gamma = gamma        self.reset()        self.N = S0 + I0 + R0    def increments(self, other=None, link=0.0, add_partial=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the         integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                 Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """                I = self.currentI if other is None else self.currentI + link*other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        deltaS = -self.beta*self.currentS*I/self.N        deltaR = self.gamma*self.currentI        deltaI = -deltaS - deltaR        return (deltaS, deltaI, deltaR)    def reset(self):        """        Returns to the original problem.        """        self._S = [self.S0]        self._I = [self.I0]        self._R = [self.R0]        return self        @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """                if not self.updated:            return self._S[-1]        else:            return self._S[-2]        @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._I[-1]        else:            return self._I[-2]        @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._R[-1]        else:            return self._R[-2]        @property    def S(self):        """        Returns a numpy.ndarray corresponding to the population of susceptible individuals.        """        return np.array(self._S)        @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self._I)        @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self._R)                class DeterministicSRI(SRI):    """    Child class of SRI. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)            def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                 ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=True)        newS = self.currentS + deltaS        newI = self.currentI + deltaI        newR = self.currentR + deltaR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return self                        class StochasticSRI(SRI):    """    Child class of SRI. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)        def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                 ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=True)        jumpS = -min(np.random.poisson(lam=np.abs(deltaS)), self.currentS)        jumpR = min(np.random.poisson(lam=np.abs(deltaR)), self.currentI)        jumpI = -(jumpS + jumpR)        newS = self.currentS + jumpS        newI = self.currentI + jumpI        newR = self.currentR + jumpR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return selfclass SEIR(ModelBase):    """    Parent class for the SEIR (susceptible-exposed-infected-recovered) model. It provides methods    and properties useful both for a deterministic and for a stochastic implementation.    """    def __init__(self, beta=0.2, alpha=0.2, gamma=0.2, initial_population=(1000, 1, 0, 0)):        """        --------------------        Parameters:            beta: float, optional                Rate of exposure of susceptible individuals. Defaults to 0.2.            alpha: float, optional                Rate of conversion from exposed to infected. Defaults to 0.2.            gamma: float, optional                Rate of recovering. Defaults to 0.2.            initial_population: tuple of int or int, optional                List representing respectively the populations of susceptible, exposed, infected and recovered                individuals. If only one integer N is provided, [N, 1, 0, 0] is assumed.        ---------------------        """        # adjust the initial_population depending on how the user provided it        if type(initial_population) is not tuple:            initial_population = [initial_population, 1, 0, 0]        elif len(initial_population) != 4:            raise Exception('Please provide either a list of four populations or an integer')        super().__init__(initial_population=initial_population)        self.alpha = alpha        self.beta = beta        self.gamma = gamma        self.partial_deltaI = 0    def increments(self, other=None, link=0.0, add_partial=False, separate_jumps=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the        integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.            separate_jumps: bool, optional                If true, the returned values are not the increments but all the changes:                    jump_1: decrease in susceptible individuals due to infected ones                    jump_2: decrease in exposed individuals                    jump_3: decrease in infected individuals                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """        I = self.currentI if other is None else self.currentI + link * other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        jump_1 = self.beta * self.currentS * I / self.N        jump_2 = self.alpha * self.currentE        jump_3 = self.gamma * self.currentI        if not separate_jumps:            deltaS = -jump_1            deltaE = jump_1 - jump_2            deltaI = jump_2 - jump_3            deltaR = jump_3            return deltaS, deltaE, deltaI, deltaR        else:            return jump_1, jump_2, jump_3    def current_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        -----------------        """        if index == 0:            return self.currentS        elif index == 1:            return self.currentE        elif index == 2:            return self.currentI        elif index == 3:            return self.currentR        else:            raise Exception('Index not valid. Only options are 0, 1, 2, or 3.')    def population_by_index(self, index):        """        Returns the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        """        if index == 0:            return self.S        elif index == 1:            return self.E        elif index == 2:            return self.I        elif index == 3:            return self.R        else:            raise Exception('Index not valid. Only options are 0, 1, 2, or 3.')    @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[0][-1]        else:            return self.population_history[0][-1]    @property    def currentE(self):        """        Returns the number of exposed individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[1][-1]        else:            return self.population_history[1][-1]    @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[2][-1]        else:            return self.population_history[2][-1]    @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[3][-1]        else:            return self.population_history[3][-1]    @property    def E(self):        """        Returns a numpy.ndarray corresponding to the population of exposed individuals.        """        return np.array(self.population_history[1])    @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self.population_history[2])    @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self.population_history[3])class DeterministicSEIR(SEIR):    """    Child class of SEIR. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEIR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEIR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        increments = self.increments(other=other, link=link, add_partial=add_partial)        return self.integrate_deterministic(self, increments)class StochasticSEIR(SEIR):    """    Child class of SEIR. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEIR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEIR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        jumps_ = self.increments(other=other, link=link, add_partial=add_partial, separate_jumps=True)        (jump_1, jump_2, jump_3) = self.stochastic_jumps(jumps_)        jump_1 = min(jump_1, self.currentS)        jump_2 = min(jump_2, self.currentE)        jump_3 = min(jump_3, self.currentI)        increments = [0]*4        increments[0] = -jump_1        increments[1] = jump_1 - jump_2        increments[2] = jump_2 - jump_3        increments[3] = jump_3        return self.integrate_deterministic(self, increments)