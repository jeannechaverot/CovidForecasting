"""@ authors: Andrei Militaru, Jeanne Chaverot@ date: 5th of April 2020"""import numpy as npclass CompartmentManager(object):        def __init__(self, parameters_list, link=1e-3, model='det'):        """model can be either 'det' or 'stoch' """        self.link = link    # so far all the same, later we should make them non-uniform        self.compartments = []        self.elapsed_days = 1        for parameters in parameters_list:            if model == 'det':                self.compartments.append(DeterministicSRI(**parameters))            elif model == 'stoch':                self.compartments.append(StochasticSRI(**parameters))            else:                raise Exception('Model not valid. Only options are \'det\' or \'stoch\'.')        def reset_state_all(self):        for cell in self.compartments:            cell.updated = False        def integrate(self):        for updating_cell in self.compartments:            for other_cell in self.compartments:                updating_cell.increment_partial(other_cell, self.link)            updating_cell.integrate(add_partial=True)            updating_cell.change_state()        self.reset_state_all()          self.elapsed_days += 1            def evolve(self, days, tqdm=False):        if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()                    @property    def S(self):        output = []        for cell in self.compartments:            output.append(cell.S)        return output                @property    def I(self):        output = []        for cell in self.compartments:            output.append(cell.I)        return output                @property    def R(self):        output = []        for cell in self.compartments:            output.append(cell.R)        return output        @property    def time(self):        return np.arange(self.elapsed_days)            class SRI(object):        def __init__(self, beta=0.2, gamma=0.5, S0=999, I0=1, R0=0):        self.S0 = S0        self.I0 = I0        self.R0 = R0        self.beta = beta        self.gamma = gamma        self.reset()        self.N = S0 + I0 + R0        self.partial_deltaI = 0        self.updated = False            def increments(self, other=None, link=0, only_other=False, add_partial=False):        I = self.currentI if other is None else self.currentI + link*other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        deltaS = -self.beta*self.currentS*I/self.N        deltaR = self.gamma*self.currentI        deltaI = -deltaS - deltaR        return (deltaS, deltaI, deltaR)        def increment_partial(self, other, link):        self.partial_deltaI += link*other.currentI        def integrate(self):        pass            def evolve(self, days, tqdm=False):        if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()                    def reset(self):        self._S = [self.S0]        self._I = [self.I0]        self._R = [self.R0]        def change_state(self):        self.updated = not self.updated        @property    def currentS(self):        if not self.updated:            return self._S[-1]        else:            return self._S[-2]        @property    def currentI(self):        if not self.updated:            return self._I[-1]        else:            return self._I[-2]        @property    def currentR(self):        if not self.updated:            return self._R[-1]        else:            return self._R[-2]        @property    def time_elapsed(self):        return len(self.S)        @property    def time(self):        return np.arange(self.time_elapsed)        @property    def S(self):        return np.array(self._S)        @property    def I(self):        return np.array(self._I)        @property    def R(self):        return np.array(self._R)                class DeterministicSRI(SRI):        def __init__(self, **kargs):        super().__init__(**kargs)            def integrate(self, other=None, link=0.1, add_partial=False):        if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=True)        newS = self.currentS + deltaS        newI = self.currentI + deltaI        newR = self.currentR + deltaR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)                        class StochasticSRI(SRI):        def __init__(self, **kargs):        super().__init__(**kargs)        def integrate(self, other=None, link=0.1, add_partial=False):        if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=True)        jumpS = -min(np.random.poisson(lam=np.abs(deltaS)), self.currentS)        jumpR = min(np.random.poisson(lam=np.abs(deltaR)), self.currentI)        jumpI = -(jumpS + jumpR)        newS = self.currentS + jumpS        newI = self.currentI + jumpI        newR = self.currentR + jumpR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)