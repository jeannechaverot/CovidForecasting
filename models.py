"""@ authors: Andrei Militaru, Jeanne Chaverot@ date: 5th of April 2020"""import numpy as npclass CompartmentManager(object):    """    Class that lets multiple cells interact with one another and evolve. In principle,    no specific model has been assumed, although for the moment only the SIR has been    implemented.    """        def __init__(self, parameters_list, link=1e-3, model='SIR', stochastic=False):        """        ---------------------        Parameters:            parameters_list: list                 dictionaries containing the keywords used in the                 initialization of the models of every cell. The number of cells is inferred                from the number of elements of paramaters_list            link: float or two dimensional numpy.ndarray,                Strength of the link between the different cells. link[i][j] represents the influence of                cell j over cell i. If given as a float, a constant matrix is assumed.                Defaults to 1e-3.            model: str, optional                Choose between different available methods. At present:                    - 'SIR' (susceptible-infected-recovered)                    - 'SEIR' (susceptible-exposed-infected-recovered)                    - 'SEInrIrR' (susceptible-exposed-infected_non_recoverable-infected_recoverable-recovered)                    - 'SEInrIrRD' (susceptible-exposed-infected_non_recoverable-infected_recoverable_recovered-dead)                Defaults to 'SIR'.            stochastic: bool, optional                If True, the evolution of the model is chosen to be stochastic.                Defaults to False.        ----------------------        """        if type(link) is float:            link = link * np.ones((len(parameters_list), len(parameters_list)))        self.link = link        self.compartments = []        self.elapsed_days = 1        for parameters in parameters_list:            if model == 'SIR':                if not stochastic:                    self.compartments.append(DeterministicSRI(**parameters))                else:                    self.compartments.append(StochasticSRI(**parameters))            elif model == 'SEIR':                if not stochastic:                    self.compartments.append(DeterministicSEIR(**parameters))                else:                    self.compartments.append(StochasticSEIR(**parameters))            elif model == 'SEInrIrR':                if not stochastic:                    self.compartments.append(DeterministicSEInrIrR(**parameters))                else:                    self.compartments.append(StochasticSEInrIrR(**parameters))            elif model == 'SEInrIrRD':                if not stochastic:                    self.compartments.append(DeterministicSEInrIrRD(**parameters))                else:                    self.compartments.append(StochasticSEInrIrRD(**parameters))            else:                raise Exception('Model not valid. Only options are \'SIR\', \'SEIR\', \'SInrIrR\' or \'SInrIrRD\'.')        def reset_state_all(self):        """        Resets the state of all the cells, meaning that the integration step is over.        """        for cell in self.compartments:            cell.updated = False        return self        def integrate(self):        """        Method that updates every cell. The cross terms in the evolution step are always        given by the population before the integration step. In order to avoid some for        some cells the evolution makes use of the already-updated populations from other        cells, an internal state of every cell is introduced.        """        for i, updating_cell in enumerate(self.compartments):            for j, other_cell in enumerate(self.compartments):                updating_cell.increment_partial(other_cell, self.link[i][j])  # due to other cells            updating_cell.integrate(add_partial=True)   # evolve cell            updating_cell.change_state()                # set cell as already updated        self.reset_state_all()                          # completion of integration step        self.elapsed_days += 1        return self            def evolve(self, days, tqdm=False):        """        Let the systems evolve for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is shown during the evolution.                Defaults to False.        -------------------        """                    if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self    def population(self, index):        """        Property that returns a list with the vector of population return elements in time.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        -----------------        """        output = []        for cell in self.compartments:            output.append(cell.population_by_index(index))        return output    '''    =========================================================    Part specific to SIR models, need to make it more general.    =========================================================    '''    @property    def S(self):        """        Property that returns a list with the vector of susceptible elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.S)        return output                @property    def I(self):        """        Property that returns a list with the vector of infected elements in time        of every cell.        """         output = []        for cell in self.compartments:            output.append(cell.I)        return output                @property    def R(self):        """        Property that returns a list with the vector of recovered elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.R)        return output        @property    def time(self):        """        Property that returns an array corresponding to the elapsed time.        """        return np.arange(self.elapsed_days)            class ModelBase(object):    """    Class that contains some of the methods used by all models to follow.    """    initial_population = None    population = None    N = None    initialized = False    population_history = None    updated = False    S_index = 0    partial_deltaI = 0    def __init__(self, initial_population=None, S_index=None):        """        ---------------        Parameters:            initial_population: list of int, optional                List of populations for the model of choice (provided by child classes).                If None, the reset method must be overloaded by the child class.        """        if initial_population is None:            pass        else:            self.population = len(initial_population)            self.initial_population = initial_population            self.N = sum(initial_population)            self.initialized = True            self.reset()            self.initialized = True            if S_index is not None:                self.S_index = S_index    def increment_partial(self, other, link):        """        Method used by instances of CompartmentManager to update the interactions with        other cells.        ------------------        Parameters:            other: instance of SRI (or its child classes)                cell that interacts with the current instance.            link: float                Interaction strength with the 'other' cell.        ------------------        """        self.partial_deltaI += link*other.currentI        return self    def reset(self):        """        If self.initialized (meaning that child class relies on this method), resets all parameters.        """        if self.initialized:            self.population_history = [[initial] for initial in self.initial_population]        else:            pass        return self    def integrate(self):        """        This method is overloaded by the child classes.        """        pass    def evolve(self, days, tqdm=False):        """        Compute evolution for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is used during the evolution.                Defaults to False.        -------------------        """        if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self    def change_state(self):        """        Method used by instance of CompartmentManager to make sure that only the        present populations are used when updating the interactions with other cells.        """        self.updated = not self.updated        return self    def population_by_index(self, index):        """        Method overloaded by child classes.        """        pass    @property    def S(self):        """        If not overloaded by child classes, returns the history of the self.S_index population.        """        if self.initialized:            return np.array(self.population_history[self.S_index])        else:            return None    @property    def time_elapsed(self):        """        Returns the number of days elapsed, given by the lengh of its populations.        It is assumed here that all models that follow have a population of susceptible individuals.        """        return len(self.S)    @property    def time(self):        """        Returns a numpy.ndarray corresponding to the elapsed time.        """        return np.arange(self.time_elapsed)    def integrate_deterministic(self, child, increments):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            child: instance of a deterministic model. The model must have a method current_by_index implemented.                See for example DeterministicSEIR.            increments: tuple of int                increments corresponding to each population type        ------------------        """        for population_type, increment in enumerate(increments):            current_value = child.current_by_index(population_type)            self.population_history[population_type].append(current_value + increment)        return self    @staticmethod    def stochastic_jumps(jumps):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            jumps: tuple of int                jumps calculated in a deterministic evolution. The function converts them to poissonian variables                and returns a realization for each.        ------------------        """        return tuple([np.random.poisson(lam=np.abs(jump)) for jump in jumps])    def update_parameters(self, **kwargs):        """        Method that takes a dictionary and resets the attributes of the instance.        ---------------------        Parameters:            kwargs: dictionary with keywords and values to be reset.        ---------------------        """        for parameter, value in kwargs.items():            setattr(self, parameter, value)        return selfclass SRI(ModelBase):    """    Parent class for SIR model. It provides methods and properties useful both for a    deterministic and for a stochastic implementation.    """        def __init__(self, beta=0.2, gamma=0.5, S0=999, I0=1, R0=0):        """        ----------------------        Paramenters:            beta: float, optional                Flow from susceptible to infected. Defaults to 0.2.            gamma: float, optional                Flow from infected to recovered. Defaults to 0.5.            S0: int, optional                Initial number of susceptible individuals.                Defaults to 999.            I0: int, optional                Initial number of infected individuals. Defaults to 1.            R0: int, optional                Initial number of recovered individuals. Defaults to 0.        -----------------------        """        super().__init__()        self.S0 = S0        self.I0 = I0        self.R0 = R0        self.beta = beta        self.gamma = gamma        self.reset()        self.N = S0 + I0 + R0    def increments(self, other=None, link=0.0, add_partial=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the         integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                 Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """                I = self.currentI if other is None else self.currentI + link*other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        deltaS = -self.beta*self.currentS*I/self.N        deltaR = self.gamma*self.currentI        deltaI = -deltaS - deltaR        return (deltaS, deltaI, deltaR)    def reset(self):        """        Returns to the original problem.        """        self._S = [self.S0]        self._I = [self.I0]        self._R = [self.R0]        return self        @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """                if not self.updated:            return self._S[-1]        else:            return self._S[-2]        @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._I[-1]        else:            return self._I[-2]        @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._R[-1]        else:            return self._R[-2]        @property    def S(self):        """        Returns a numpy.ndarray corresponding to the population of susceptible individuals.        """        return np.array(self._S)        @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self._I)        @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self._R)                class DeterministicSRI(SRI):    """    Child class of SRI. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)            def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=True)        newS = self.currentS + deltaS        newI = self.currentI + deltaI        newR = self.currentR + deltaR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return self                        class StochasticSRI(SRI):    """    Child class of SRI. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)        def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=True)        jumpS = -min(np.random.poisson(lam=np.abs(deltaS)), self.currentS)        jumpR = min(np.random.poisson(lam=np.abs(deltaR)), self.currentI)        jumpI = -(jumpS + jumpR)        newS = self.currentS + jumpS        newI = self.currentI + jumpI        newR = self.currentR + jumpR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return selfclass SEIR(ModelBase):    """    Parent class for the SEIR (susceptible-exposed-infected-recovered) model. It provides methods    and properties useful both for a deterministic and for a stochastic implementation.    """    def __init__(self, beta=0.2, alpha=0.2, gamma=0.2, initial_population=(1000, 1, 0, 0)):        """        --------------------        Parameters:            beta: float, optional                Rate of exposure of susceptible individuals. Defaults to 0.2.            alpha: float, optional                Rate of conversion from exposed to infected. Defaults to 0.2.            gamma: float, optional                Rate of recovering. Defaults to 0.2.            initial_population: tuple of int or int, optional                List representing respectively the populations of susceptible, exposed, infected and recovered                individuals. If only one integer N is provided, [N, 1, 0, 0] is assumed.        ---------------------        """        # adjust the initial_population depending on how the user provided it        if type(initial_population) is not tuple:            initial_population = [initial_population, 1, 0, 0]        elif len(initial_population) != 4:            raise Exception('Please provide either a list of four populations or an integer')        super().__init__(initial_population=initial_population)        self.alpha = alpha        self.beta = beta        self.gamma = gamma        self.partial_deltaI = 0    def increments(self, other=None, link=0.0, add_partial=False, separate_jumps=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the        integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.            separate_jumps: bool, optional                If true, the returned values are not the increments but all the changes:                    jump_1: decrease in susceptible individuals due to infected ones                    jump_2: decrease in exposed individuals                    jump_3: decrease in infected individuals                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """        I = self.currentI if other is None else self.currentI + link * other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        jump_1 = self.beta * self.currentS * I / self.N        jump_2 = self.alpha * self.currentE        jump_3 = self.gamma * self.currentI        if not separate_jumps:            deltaS = -jump_1            deltaE = jump_1 - jump_2            deltaI = jump_2 - jump_3            deltaR = jump_3            return deltaS, deltaE, deltaI, deltaR        else:            return jump_1, jump_2, jump_3    def current_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        -----------------        """        if index == 0:            return self.currentS        elif index == 1:            return self.currentE        elif index == 2:            return self.currentI        elif index == 3:            return self.currentR        else:            raise Exception('Index not valid. Only options are 0, 1, 2, or 3.')    def population_by_index(self, index):        """        Returns the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected                if 3, recovered        """        if index == 0:            return self.S        elif index == 1:            return self.E        elif index == 2:            return self.I        elif index == 3:            return self.R        else:            raise Exception('Index not valid. Only options are 0, 1, 2, or 3.')    @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[0][-1]        else:            return self.population_history[0][-2]    @property    def currentE(self):        """        Returns the number of exposed individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[1][-1]        else:            return self.population_history[1][-2]    @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[2][-1]        else:            return self.population_history[2][-2]    @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[3][-1]        else:            return self.population_history[3][-2]    @property    def E(self):        """        Returns a numpy.ndarray corresponding to the population of exposed individuals.        """        return np.array(self.population_history[1])    @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self.population_history[2])    @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self.population_history[3])class DeterministicSEIR(SEIR):    """    Child class of SEIR. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEIR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEIR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        increments = self.increments(other=other, link=link, add_partial=add_partial)        return self.integrate_deterministic(self, increments)class StochasticSEIR(SEIR):    """    Child class of SEIR. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEIR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEIR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        jumps_ = self.increments(other=other, link=link, add_partial=add_partial, separate_jumps=True)        (jump_1, jump_2, jump_3) = self.stochastic_jumps(jumps_)        jump_1 = min(jump_1, self.currentS)        jump_2 = min(jump_2, self.currentE)        jump_3 = min(jump_3, self.currentI)        increments = [0]*4        increments[0] = -jump_1        increments[1] = jump_1 - jump_2        increments[2] = jump_2 - jump_3        increments[3] = jump_3        return self.integrate_deterministic(self, increments)class SEInrIrR(ModelBase):    """     Parent class for the SEIiR (susceptible-exposed-infected_non_recoverable-infected_recoverable-recovered) model. It     provides methods and properties useful both for a deterministic and for a stochastic implementation.     """    def __init__(self, beta=0.2, alpha=0.2, gamma=0.2, delta=0.2, initial_population=(1000, 1, 0, 0, 0)):        """        --------------------        Parameters:            beta: float, optional                Rate of exposure of susceptible individuals. Defaults to 0.2.            alpha: float, optional                Rate of conversion from exposed to infected. Defaults to 0.2.            gamma: float, optional                Rate of recovering. Defaults to 0.2.            delta: float, optional                Flow rate between infected who cannot recover to infected who can recover.            initial_population: tuple of int or int, optional                List representing respectively the populations of susceptible, exposed, infected, infected_non_recoverable                infected_recoverable and recovered individuals. If only one integer N is provided, [N, 1, 0, 0, 0]                is assumed.        ---------------------        """        # adjust the initial_population depending on how the user provided it        if type(initial_population) is not tuple:            initial_population = [initial_population, 1, 0, 0, 0]        elif len(initial_population) != 5:            raise Exception('Please provide either a list of four populations or an integer')        super().__init__(initial_population=initial_population)        self.alpha = alpha        self.beta = beta        self.gamma = gamma        self.delta = delta        self.partial_deltaI = 0    def increments(self, other=None, link=0.0, add_partial=False, separate_jumps=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the        integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.            separate_jumps: bool, optional                If true, the returned values are not the increments but all the changes:                    jump_1: decrease in susceptible individuals due to infected ones                    jump_2: decrease in exposed individuals                    jump_3: decrease in infected individuals                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """        Inr = self.currentInr if other is None else self.currentInr + link * other.currentInr        Ir = self.currentIr if other is None else self.currentIr + link * other.currentIr        if add_partial:            dI = self.partial_deltaI            self.partial_deltaI = 0        else:            dI = 0        jump_1 = self.beta * self.currentS * (Inr + Ir + dI) / self.N        jump_2 = self.alpha * self.currentE        jump_3 = self.delta * self.currentInr        jump_4 = self.gamma * self.currentIr        if not separate_jumps:            deltaS = -jump_1            deltaE = jump_1 - jump_2            deltaInr = jump_2 - jump_3            deltaIr = jump_3 - jump_4            deltaR = jump_4            return deltaS, deltaE, deltaInr, deltaIr, deltaR        else:            return jump_1, jump_2, jump_3, jump_4    def current_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected and not recoverable                if 3, infected but recoverable                if 4, recovered        -----------------        """        if index == 0:            return self.currentS        elif index == 1:            return self.currentE        elif index == 2:            return self.currentInr        elif index == 3:            return self.currentIr        elif index == 4:            return self.currentR        else:            raise Exception('Index not valid. Only options are 0, 1, 2, or 3.')    def population_by_index(self, index):        """        Returns the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected and not recoverable                if 3, infected but recoverable                if 4, recovered        """        if index == 0:            return self.S        elif index == 1:            return self.E        elif index == 2:            return self.Inr        elif index == 3:            return self.Ir        elif index == 4:            return self.R        else:            raise Exception('Index not valid. Only options are 0, 1, 2, 3 or 4.')    @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[0][-1]        else:            return self.population_history[0][-2]    @property    def currentE(self):        """        Returns the number of exposed individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[1][-1]        else:            return self.population_history[1][-2]    @property    def currentInr(self):        """        Returns the number of infected_non_recoverable individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[2][-1]        else:            return self.population_history[2][-2]    @property    def currentIr(self):        """        Returns the number of infected_recoverable individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[3][-1]        else:            return self.population_history[3][-2]    @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[4][-1]        else:            return self.population_history[4][-2]    @property    def E(self):        """        Returns a numpy.ndarray corresponding to the population of exposed individuals.        """        return np.array(self.population_history[1])    @property    def Inr(self):        """        Returns a numpy.ndarray corresponding to the population of infected_non_recoverable individuals.        """        return np.array(self.population_history[3])    @property    def Ir(self):        """        Returns a numpy.ndarray corresponding to the population of infected_recoverable individuals.        """        return np.array(self.population_history[4])    @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self.population_history[5])    @property    def I(self):        """        Returns a numpy.ndarray corresponding to the total population of infected individuals (Inr + Ir).        """        return self.Inr + self.Irclass DeterministicSEInrIrR(SEInrIrR):    """    Child class of SEInrIrR. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEInrIrR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEInrIrR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        increments = self.increments(other=other, link=link, add_partial=add_partial)        return self.integrate_deterministic(self, increments)class StochasticSEInrIrR(SEInrIrR):    """    Child class of SEInrIrR. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEInrIrR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEInrIrR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        jumps_ = self.increments(other=other, link=link, add_partial=add_partial, separate_jumps=True)        (jump_1, jump_2, jump_3, jump_4) = self.stochastic_jumps(jumps_)        jump_1 = min(jump_1, self.currentS)        jump_2 = min(jump_2, self.currentE)        jump_3 = min(jump_3, self.currentInr)        jump_4 = min(jump_4, self.currentIr)        increments = [0]*5        increments[0] = -jump_1        increments[1] = jump_1 - jump_2        increments[2] = jump_2 - jump_3        increments[3] = jump_3 - jump_4        increments[4] = jump_4        return self.integrate_deterministic(self, increments)class SEInrIrRD(ModelBase):    """     Parent class for the SEIiRD (susceptible-exposed-infected_non_recoverable-infected_recoverable-recovered-dead) model. It     provides methods and properties useful both for a deterministic and for a stochastic implementation.     """    def __init__(self,                 beta=0.2,                 alpha=0.2,                 gamma=0.2,                 delta=0.2,                 xi=0.2,                 lambda_E = 0.0,                 lambda_I = 0.1,                 lambda_R = 0.01,                 initial_population=(1000, 1, 0, 0, 0)):        """        --------------------        Parameters:            beta: float, optional                Rate of exposure of susceptible individuals. Defaults to 0.2.            alpha: float, optional                Rate of conversion from exposed to infected. Defaults to 0.2.            gamma: float, optional                Rate of recovering. Defaults to 0.2.            delta: float, optional                Flow rate between infected who cannot recover to infected who can recover.            xi: float, optional                Death rate from the infected_non_recoverable stage.                defaults to 0.2.            lambda_E: float, optional                Rate of transition from the exposed to the susceptible stage. In layman terms, rate of "false alarm".                Defaults to 0.            lambda_I: float, optional                Rate of transition from the infected_recoverable to the susceptible stage. In layman terms, it is related                to the fraction of individuals who do not develop immunity.                Defaults to 0.1.            lambda_R: float, optional                Rate of transition from recovered state to susceptible state. In layman terms, it is related to the                amount of time after which individuals lose their immunity to the virus.            initial_population: tuple of int or int, optional                List representing respectively the populations of susceptible, exposed, infected, infected_non_recoverable                infected_recoverable and recovered individuals. If only one integer N is provided, [N, 1, 0, 0, 0]                is assumed.        ---------------------        """        # adjust the initial_population depending on how the user provided it        if type(initial_population) is not tuple:            initial_population = [initial_population, 1, 0, 0, 0, 0]        elif len(initial_population) != 6:            raise Exception('Please provide either a list of four populations or an integer')        super().__init__(initial_population=initial_population)        self.alpha = alpha        self.beta = beta        self.gamma = gamma        self.delta = delta        self.xi = xi        self.lambda_E = lambda_E        self.lambda_I = lambda_I        self.lambda_R = lambda_R        self.partial_deltaI = 0    def increments(self, other=None, link=0.0, add_partial=False, separate_jumps=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the        integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.            separate_jumps: bool, optional                If true, the returned values are not the increments but all the changes:                    jump_1: decrease in susceptible individuals due to infected ones                    jump_2: decrease in exposed individuals                    jump_3: decrease in infected individuals                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """        Inr = self.currentInr if other is None else self.currentInr + link * other.currentInr        Ir = self.currentIr if other is None else self.currentIr + link * other.currentIr        if add_partial:            dI = self.partial_deltaI            self.partial_deltaI = 0        else:            dI = 0        jump_1 = self.beta * self.currentS * (Inr + Ir + dI) / self.N        jump_2 = self.lambda_E * self.currentE        jump_3 = self.lambda_I * self.currentIr        jump_4 = self.lambda_R * self.currentR        jump_5 = self.alpha * self.currentE        jump_6 = self.delta * self.currentInr        jump_7 = self.gamma * self.currentIr        jump_8 = self.xi * self.currentInr        if not separate_jumps:            deltaS = -jump_1 + jump_2 + jump_3 + jump_4            deltaE = jump_1 - jump_5 - jump_2            deltaInr = jump_5 - jump_6 - jump_8            deltaIr = jump_6 - jump_7 - jump_3            deltaR = jump_7 - jump_4            deltaD = jump_8            return deltaS, deltaE, deltaInr, deltaIr, deltaR, deltaD        else:            return jump_1, jump_2, jump_3, jump_4, jump_5, jump_6, jump_7, jump_8    def current_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected and not recoverable                if 3, infected but recoverable                if 4, recovered                if 5, dead        -----------------        """        if index == 0:            return self.currentS        elif index == 1:            return self.currentE        elif index == 2:            return self.currentInr        elif index == 3:            return self.currentIr        elif index == 4:            return self.currentR        elif index == 5:            return self.currentD        else:            raise Exception('Index not valid. Only options are 0, 1, 2, 3, 4 or 5.')    def population_by_index(self, index):        """        Returns the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, exposed                if 2, infected and not recoverable                if 3, infected but recoverable                if 4, recovered                if 5, dead        """        if index == 0:            return self.S        elif index == 1:            return self.E        elif index == 2:            return self.Inr        elif index == 3:            return self.Ir        elif index == 4:            return self.R        elif index == 5:            return self.D        else:            raise Exception('Index not valid. Only options are 0, 1, 2, 3, 4 or 5.')    @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[0][-1]        else:            return self.population_history[0][-2]    @property    def currentE(self):        """        Returns the number of exposed individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[1][-1]        else:            return self.population_history[1][-2]    @property    def currentInr(self):        """        Returns the number of infected_non_recoverable individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[2][-1]        else:            return self.population_history[2][-2]    @property    def currentIr(self):        """        Returns the number of infected_recoverable individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[3][-1]        else:            return self.population_history[3][-2]    @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[4][-1]        else:            return self.population_history[4][-2]    @property    def currentD(self):        """        Returns the number of dead individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[5][-1]        else:            return self.population_history[5][-2]    @property    def E(self):        """        Returns a numpy.ndarray corresponding to the population of exposed individuals.        """        return np.array(self.population_history[1])    @property    def Inr(self):        """        Returns a numpy.ndarray corresponding to the population of infected_non_recoverable individuals.        """        return np.array(self.population_history[2])    @property    def Ir(self):        """        Returns a numpy.ndarray corresponding to the population of infected_recoverable individuals.        """        return np.array(self.population_history[3])    @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self.population_history[4])    @property    def I(self):        """        Returns a numpy.ndarray corresponding to the total population of infected individuals (Inr + Ir).        """        return self.Inr + self.Ir    @property    def D(self):        """        Returns a numpy.ndarray corresponding to the population of dead individuals.        """        return np.array(self.population_history[5])class DeterministicSEInrIrRD(SEInrIrRD):    """    Child class of SEInrIrRD. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEInrIrRD.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEInrIrR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        increments = self.increments(other=other, link=link, add_partial=add_partial)        return self.integrate_deterministic(self, increments)class StochasticSEInrIrRD(SEInrIrRD):    """    Child class of SEInrIrRD. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SEInrIrR.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SEInrIrR (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        jumps_ = self.increments(other=other, link=link, add_partial=add_partial, separate_jumps=True)        (jump_1,         jump_2,         jump_3,         jump_4,         jump_5,         jump_6,         jump_7,         jump_8) = self.stochastic_jumps(jumps_)        jump_1 = min(jump_1, self.currentS)        jump_4 = min(jump_4, self.currentR)        jump_5 = min(jump_5, self.currentE)        jump_6 = min(jump_6, self.currentInr)        jump_7 = min(jump_7, self.currentIr)        increments = [0]*6        increments[0] = -jump_1 + jump_2 + jump_3 + jump_4        increments[1] = jump_1 - jump_5 - jump_2        increments[2] = jump_5 - jump_6 - jump_8        increments[3] = jump_6 - jump_7 - jump_3        increments[4] = jump_7 - jump_4        increments[5] = jump_8        return self.integrate_deterministic(self, increments)class SIndIDRDndRnd(ModelBase):    """    Class that implements the    susceptible-infected_non_detected-infected-recovered_non_detected-recovered-dead_non_detected-dead.    """    def __init__(self,                 beta=0.2,                 delta=0.5,                 alpha=0.2,                 xi_nd=0.1,                 xi=0.2,                 xi2=0.01,                 gamma_nd=0.2,                 gamma=0.1,                 initial_population=(1000, 1, 0, 0, 0)):        """        --------------------        Parameters:            beta: float, optional                Rate of exposure of susceptible individuals. Defaults to 0.2.            alpha: float, optional                Rate of detection of infected_non_detected to infected.                Defaults to 0.5.            gamma: float, optional                Rate of recovering from detected infected stage to detected recovered stage. Defaults to 0.2.            delta: float, optional                Correction factor for the contagiousness of non-detected individuals (assumed to have mild symptoms).                Defaults to 0.5            xi: float, optional                Death rate from the infected stage to the detected dead stage.                defaults to 0.2.            xi_nd: float, optional                Death rate from the infected_non_detected stage to the dead_non_detected stage.                Defaults to 0.1.            xi2: float, optional                Death rate from the infected_non_detected stage to the dead stage (post-mortem testing).                Defaults to 0.01.            gamma_nd: float, optional                Rate of recovery from the infected_non_detected stage to the recovered_non_detected stage.                Defaults to 0.2.            initial_population: tuple of int or int, optional                List representing respectively the populations of susceptible, exposed, infected, infected_non_recoverable                infected_recoverable and recovered individuals. If only one integer N is provided, [N, 1, 0, 0, 0, 0, 0]                is assumed.        ---------------------        """        # adjust the initial_population depending on how the user provided it        if type(initial_population) is not tuple:            initial_population = [initial_population, 1, 0, 0, 0, 0, 0]        elif len(initial_population) != 7:            raise Exception('Please provide either a list of seven populations or an integer.')        super().__init__(initial_population=initial_population)        self.alpha = alpha        self.beta = beta        self.gamma = gamma        self.delta = delta        self.xi = xi        self.gamma_nd = gamma_nd        self.xi_nd = xi_nd        self.xi2 = xi2        self.partial_deltaI = 0    def increments(self, other=None, link=0.0, add_partial=False, separate_jumps=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the        integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SIndIRRndDDnd (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.            separate_jumps: bool, optional                If true, the returned values are not the increments but all the changes:                    jump_1: decrease in susceptible individuals due to infected ones                    jump_2: decrease in exposed individuals                    jump_3: decrease in infected individuals                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """        I_nd = self.currentI_nd if other is None else self.currentI_nd + link * other.currentI_nd        I = self.currentI if other is None else self.currentI + link * other.currentI        if add_partial:            dI = self.partial_deltaI            self.partial_deltaI = 0        else:            dI = 0        jump_1 = self.beta * self.currentS * (self.delta * I_nd + I + dI) / self.N        jump_2 = self.alpha * self.currentI_nd        jump_3 = self.xi_nd * self.currentI_nd        jump_4 = self.gamma_nd * self.currentI_nd        jump_5 = self.xi2 * self.currentI_nd        jump_6 = self.gamma * self.currentI        jump_7 = self.xi * self.currentI        if not separate_jumps:            deltaS = -jump_1            deltaI_nd = jump_1 - jump_2 - jump_3 - jump_4 - jump_5            deltaI = jump_2 - jump_7 - jump_6            deltaR = jump_6            deltaD = jump_5 + jump_7            deltaR_nd = jump_4            deltaD_nd = jump_3            return deltaS, deltaI_nd, deltaI, deltaD, deltaR, deltaD_nd, deltaR_nd        else:            return jump_1, jump_2, jump_3, jump_4, jump_5, jump_6, jump_7    def current_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, infected_non_detected                if 2, infected                if 3, dead                if 4, recovered                if 5, dead_non_detected                if 6, recovered_non_detected        -----------------        """        if index == 0:            return self.currentS        elif index == 1:            return self.currentI_nd        elif index == 2:            return self.currentI        elif index == 3:            return self.currentD        elif index == 4:            return self.currentR        elif index == 5:            return self.currentD_nd        elif index == 6:            return self.currentR_nd        else:            raise Exception('Index not valid. Only options are 0, 1, 2, 3, 4, 5 or 6.')    def population_by_index(self, index):        """        Returns the current value of the population corresponding to index.        -----------------        Parameters:             index: int                if 0, susceptible                if 1, infected_non_detected                if 2, infected                if 3, dead                if 4, recovered                if 5, dead_non_detected                if 6, recovered_non_detected        -----------------        """        if index == 0:            return self.S        elif index == 1:            return self.I_nd        elif index == 2:            return self.I        elif index == 3:            return self.D        elif index == 4:            return self.R        elif index == 5:            return self.D_nd        elif index == 6:            return self.R_nd        else:            raise Exception('Index not valid. Only options are 0, 1, 2, 3, 4, 5 or 6.')    @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[0][-1]        else:            return self.population_history[0][-2]    @property    def currentI_nd(self):        """        Returns the number of infected_non_detected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[1][-1]        else:            return self.population_history[1][-2]    @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[2][-1]        else:            return self.population_history[2][-2]    @property    def currentD(self):        """        Returns the number of dead individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[3][-1]        else:            return self.population_history[3][-2]    @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[4][-1]        else:            return self.population_history[4][-2]    @property    def currentD_nd(self):        """        Returns the number of dead_non_detected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[5][-1]        else:            return self.population_history[5][-2]    @property    def currentR_nd(self):        """        Returns the number of recovered_non_detected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the        second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self.population_history[6][-1]        else:            return self.population_history[6][-2]    @property    def I_nd(self):        """        Returns a numpy.ndarray corresponding to the population of infected_non_detected individuals.        """        return np.array(self.population_history[1])    @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self.population_history[2])    @property    def D(self):        """        Returns a numpy.ndarray corresponding to the population of dead individuals.        """        return np.array(self.population_history[3])    @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self.population_history[4])    @property    def D_nd(self):        """        Returns a numpy.ndarray corresponding to the population of dead_non_detected individuals.        """        return np.array(self.population_history[5])    @property    def R_nd(self):        """        Returns a numpy.ndarray corresponding to the population of recovered_non_detected individuals.        """        return np.array(self.population_history[6])class DeterministicSIndIDRDndRnd(SIndIDRDndRnd):    """    Child class of SIndIDRDndRnd. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SIndIDRDndRnd.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SIndIDRDndRnd (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        increments = self.increments(other=other, link=link, add_partial=add_partial)        return self.integrate_deterministic(self, increments)class StochasticSIndIDRDndRnd(SIndIDRDndRnd):    """    Child class of SIndIDRDndRnd. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SIndIDRDndRnd.        --------------        """        super().__init__(**kwargs)    def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SIndIDRDndRnd (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strength with the 'other' cell. If other is None, it is                ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """        jumps_ = self.increments(other=other, link=link, add_partial=add_partial, separate_jumps=True)        (jump_1,         jump_2,         jump_3,         jump_4,         jump_5,         jump_6,         jump_7) = self.stochastic_jumps(jumps_)        jump_1 = min(jump_1, self.currentS)        if self.alpha > self.gamma_nd:            jump_2 = min(jump_2, self.currentI_nd)        elif self.alpha < self.gamma_nd:            jump_4 = min(jump_4, self.currentI_nd)        else:            jump_2 = min(jump_2, int(self.currentI_nd/2))            jump_4 = min(jump_4, int(self.currentI_nd/2))        jump_6 = min(jump_6, self.currentI)        increments = [0]*7        increments[0] = -jump_1        increments[1] = jump_1 - jump_2 - jump_3 - jump_4 - jump_5        increments[2] = jump_2 - jump_7 - jump_6        increments[3] = jump_6        increments[4] = jump_5 + jump_7        increments[5] = jump_4        increments[6] = jump_3        return self.integrate_deterministic(self, increments)