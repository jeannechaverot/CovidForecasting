"""@ authors: Andrei Militaru, Jeanne Chaverot@ date: 5th of April 2020"""import numpy as npclass CompartmentManager(object):    """    Class that lets multiple cells interact with one another and evolve. In principle,    no specific model has been assumed, although for the moment only the SIR has been    implemented.    """        def __init__(self, parameters_list, link=1e-3, model='det'):        """        ---------------------        Parameters:            parameters_list: list                 dictionaries containing the keywords used in the                 initialization of the models of every cell. The number of cells is inferred                from the number of elements of paramaters_list            link: float, optional                strenght of interaction between the cell. At the present time, every cell                is assumed to interact in the same way with all the others.                Defaults to 1e-3.            model: str, optional                At the present time, the only options are 'det' and 'stoc', both referring                to a SIR model. Defaults to 'det'.        ----------------------        """                        self.link = link    # so far all the same, later we should make them non-uniform        self.compartments = []        self.elapsed_days = 1        for parameters in parameters_list:            if model == 'det':                self.compartments.append(DeterministicSRI(**parameters))            elif model == 'stoch':                self.compartments.append(StochasticSRI(**parameters))            else:                raise Exception('Model not valid. Only options are \'det\' or \'stoch\'.')        def reset_state_all(self):        """        Resets the state of all the cells, meaning that the integration step is over.        """        for cell in self.compartments:            cell.updated = False        return self        def integrate(self):        """        Method that updates every cell. The cross terms in the evolution step are always        given by the population before the integration step. In order to avoid some for        some cells the evolution makes use of the already-updated populations from other        cells, an internal state of every cell is introduced.        """        for updating_cell in self.compartments:            for other_cell in self.compartments:                updating_cell.increment_partial(other_cell, self.link)  # due to other cells            updating_cell.integrate(add_partial=True)   # evolve cell            updating_cell.change_state()                # set cell as already updated        self.reset_state_all()                          # completion of integration step        self.elapsed_days += 1        return self            def evolve(self, days, tqdm=False):        """        Let the systems evolve for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is shown during the evolution.                Defaults to False.        -------------------        """                    if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self            '''    =========================================================    Part specific to SIR models, need to make it more general.    =========================================================    '''        @property    def S(self):        """        Property that returns a list with the vector of susceptible elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.S)        return output                @property    def I(self):        """        Property that returns a list with the vector of infected elements in time        of every cell.        """         output = []        for cell in self.compartments:            output.append(cell.I)        return output                @property    def R(self):        """        Property that returns a list with the vector of recovered elements in time        of every cell.        """        output = []        for cell in self.compartments:            output.append(cell.R)        return output        @property    def time(self):        """        Property that returns an array corresponding to the elapsed time.        """        return np.arange(self.elapsed_days)            class SRI(object):    """    Parent class for SIR model. It provides methods and properties useful both for a    deterministic and for a stochastic implementation.    """        def __init__(self, beta=0.2, gamma=0.5, S0=999, I0=1, R0=0):        """        ----------------------        Paramenters:            beta: float, optional                Flow from susceptible to infected. Defaults to 0.2.            gamma: float, optional                Flow from infected to recovered. Defaults to 0.5.            S0: int, optional                Initial number of susceptible individuals.                Defaults to 999.            I0: int, optional                Initial number of infected individuals. Defaults to 1.            R0: int, optional                Initial number of recovered individuals. Defaults to 0.        -----------------------        """        self.S0 = S0        self.I0 = I0        self.R0 = R0        self.beta = beta        self.gamma = gamma        self.reset()        self.N = S0 + I0 + R0        self.partial_deltaI = 0        self.updated = False            def increments(self, other=None, link=0, only_other=False, add_partial=False):        """        Method that computes the increments for the next integration steps.        For deterministic models, the computed increments are used directly in the         integrate method. For stochastic models, they are first converted to a poissonian        random variable with the same expected value.        -------------------        Parameters:            other: instance of SRI (or its child classes)                Used in the interaction between cells, 'other' is the cell from which                individuals are currently influencing the evolution.                Defaults to None, meaning that no other cell is influencing the current                instance.            link: float, optional                 Interaction strength with cell represented by the variable 'other'.                Defaults to 0.            only_other: bool, optional                If True, the increments are only due to the other cell and the results are                stored in self.partial variables. Instances of CompartmentManager                 take care of this. Defaults to False.            add_partial: bool, optional                If True, the increments are calculated both due to the present instance                and due to the partial values stored from previous interactions with other                cells. Instances of CompartmentManager take care of this.                Defaults to False.        ---------------------        Returns:            tuple of the three increments for the three types of population.        ---------------------        """                I = self.currentI if other is None else self.currentI + link*other.currentI        if add_partial:            I += self.partial_deltaI            self.partial_deltaI = 0        deltaS = -self.beta*self.currentS*I/self.N        deltaR = self.gamma*self.currentI        deltaI = -deltaS - deltaR        return (deltaS, deltaI, deltaR)        def increment_partial(self, other, link):        """        Method used by instances of CompartmentManager to update the interactions with        other cells.        ------------------        Parameters:            other: instance of SRI (or its child classes)                cell that interacts with the current instance.            link: float                Interaction strength with the 'other' cell.        ------------------        """        self.partial_deltaI += link*other.currentI        return self        def integrate(self):        """        This method is overloaded by the child classes.        """        pass            def evolve(self, days, tqdm=False):        """        Compute evolution for a given number of days.        -------------------        Parameters:            days: int                Number of consecutive integration steps required.            tqdm: bool, optional                If true, a loading bar in tqdm style is used during the evolution.                Defaults to False.        -------------------        """        if tqdm:            for i in tqdm(range(days)):                self.integrate()        else:            for i in range(days):                self.integrate()        return self                    def reset(self):        """        Returns to the original problem.        """                self._S = [self.S0]        self._I = [self.I0]        self._R = [self.R0]                return self        def change_state(self):        """        Method used by instance of CompartmentManager to make sure that only the         present populations are used when updating the interactions with other cells.        """                self.updated = not self.updated        return self        @property    def currentS(self):        """        Returns the number of susceptible individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """                if not self.updated:            return self._S[-1]        else:            return self._S[-2]        @property    def currentI(self):        """        Returns the number of infected individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._I[-1]        else:            return self._I[-2]        @property    def currentR(self):        """        Returns the number of recovered individuals used in the update for the next stage.        If self.updated, it means that during the integration step of a set of cells, the        present instance has already been updated. Thus, when updating other cells, the         second to last element should be used, since that was the value before the updating        step.        """        if not self.updated:            return self._R[-1]        else:            return self._R[-2]        @property    def time_elapsed(self):        """        Returns the number of days elapsed, given by the lengh of its populations.        """        return len(self.S)        @property    def time(self):        """        Returns a numpy.ndarray corresponding to the elapsed time.        """        return np.arange(self.time_elapsed)        @property    def S(self):        """        Returns a numpy.ndarray corresponding to the population of susceptible individuals.        """        return np.array(self._S)        @property    def I(self):        """        Returns a numpy.ndarray corresponding to the population of infected individuals.        """        return np.array(self._I)        @property    def R(self):        """        Returns a numpy.ndarray corresponding to the population of recovered individuals.        """        return np.array(self._R)                class DeterministicSRI(SRI):    """    Child class of SRI. It implements a deterministic evolution of the system.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)            def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                 ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link,                                                         add_partial=True)        newS = self.currentS + deltaS        newI = self.currentI + deltaI        newR = self.currentR + deltaR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return self                        class StochasticSRI(SRI):    """    Child class of SRI. It implements a stochastic evolution of the system. In contrast    to the deterministic model, the increments are computed as a poissonian random variable.    """    def __init__(self, **kwargs):        """        --------------        Parameters:            kwargs: see doc string of class SRI.        --------------        """        super().__init__(**kwargs)        def integrate(self, other=None, link=0.1, add_partial=False):        """        Method that integrates the model to the next day (forwards Euler).        -----------------        Parameters:            other: instance of SRI (or its child classes), optional                Cell with which the current instance is interacting. Defaults to None,                meaning that no interaction is currently happening.            link: float, optional                Interaction strenght with the 'other' cell. If other is None, it is                 ignored. Defaults to 0.1.            add_partial: bool, optional                If true, the increments stored in self.partial attributes are also added.                After making use of self.partial, they are reset to 0, as the interaction                step is over. Defaults to False.        ------------------        """                if not add_partial:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=False)        else:            (deltaS, deltaI, deltaR) = self.increments(other=other, link=link, add_partial=True)        jumpS = -min(np.random.poisson(lam=np.abs(deltaS)), self.currentS)        jumpR = min(np.random.poisson(lam=np.abs(deltaR)), self.currentI)        jumpI = -(jumpS + jumpR)        newS = self.currentS + jumpS        newI = self.currentI + jumpI        newR = self.currentR + jumpR        self._S.append(newS)        self._I.append(newI)        self._R.append(newR)        return self